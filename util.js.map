{"version":3,"file":"util.js","sources":["../node_modules/@alttiri/util-js/src/util.js","../node_modules/@alttiri/util-js/src/date-formatter.js","../node_modules/@alttiri/util-js/src/delay.js","../node_modules/@alttiri/util-js/src/sleep.js","../node_modules/@alttiri/string-magic/src/util-hostname.js","../node_modules/@alttiri/string-magic/src/title-cleaner.js","../node_modules/@alttiri/string-magic/src/url-cleaner.js"],"sourcesContent":["export function isString(value) {\n    return typeof value === \"string\";\n}\nexport function isAnyString(value) {\n    return typeof value === \"string\" || value instanceof String;\n}\n/**\n * Java's `hashCode` like.\n * @example\n * hashString(\"Lorem Ipsum\") === -488052133\n * hashString(\"Qwerty\") === -1862984904\n * hashString(\"A\") === 65\n * hashString(\"ðŸ‘¾ðŸ‘½ðŸ’€\") === -2019372252\n * @param {string} str\n * @return {number}\n */\nexport function hashString(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash = Math.imul(Math.imul(31, hash) + str.charCodeAt(i), 1);\n    }\n    return hash;\n}\n","import { isString } from \"./util.js\";\n/**\n * \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10\"\n * @param {Date | string | number?} [dateValue]\n * @param {boolean} [utc = true]\n * @return {string}\n */\nexport function dateToDayDateString(dateValue, utc = true) {\n    return formatDate(dateValue, \"YYYY.MM.DD\", utc);\n}\n/**\n * \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10 22:22:22Z\"\n * @param {Date | string | number} [dateValue]\n * @param {boolean?} [utc = true]\n * @return {string}\n */\nexport function dateToDayDateTimeString(dateValue, utc = true) {\n    return formatDate(dateValue, \"YYYY.MM.DD HH:mm:SS\", utc) + (utc ? \"Z\" : \"\");\n}\n/**\n * \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10 22:22:22\"\n * @param {Date | string | number} [dateValue]\n * @return {string}\n */\nexport function localDate(dateValue) {\n    return dateToDayDateString(dateValue, false);\n}\n/**\n * \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10\"\n * @param {Date | string | number} [dateValue]\n * @return {string}\n */\nexport function localDateTime(dateValue) {\n    return dateToDayDateTimeString(dateValue, false);\n}\n/**\n * Formats date. Supports: YY.YYYY.MM.DD HH:mm:SS.\n * Default format: \"YYYY.MM.DD\".\n * formatDate() -> \"2022.01.07\"\n * @param {Date | string | number} [dateValue]\n * @param {string}  [pattern = \"YYYY.MM.DD\"]\n * @param {boolean} [utc = true]\n * @return {string}\n */\nexport function formatDate(dateValue = new Date(), pattern = \"YYYY.MM.DD\", utc = true) {\n    dateValue = firefoxDateFix(dateValue);\n    const date = new Date(dateValue);\n    if (date.toString() === \"Invalid Date\") {\n        console.warn(\"Invalid Date value: \", dateValue);\n    }\n    const formatter = new DateFormatter(date, utc);\n    return pattern.replaceAll(/YYYY|YY|MM|DD|HH|mm|SS/g, (...args) => {\n        const property = args[0];\n        return formatter[property];\n    });\n}\nfunction firefoxDateFix(dateValue) {\n    if (isString(dateValue)) {\n        return dateValue.replace(/(?<y>\\d{4})\\.(?<m>\\d{2})\\.(?<d>\\d{2})/, \"$<y>-$<m>-$<d>\");\n    }\n    return dateValue;\n}\n/** @return {string} */\nfunction pad0(value, count = 2) {\n    return value.toString().padStart(count, \"0\");\n}\nclass DateFormatter {\n    constructor(date = new Date(), utc = true) {\n        this.date = date;\n        this.utc = utc ? \"UTC\" : \"\";\n    }\n    get SS() { return pad0(this.date[`get${this.utc}Seconds`]()); }\n    get mm() { return pad0(this.date[`get${this.utc}Minutes`]()); }\n    get HH() { return pad0(this.date[`get${this.utc}Hours`]()); }\n    get MM() { return pad0(this.date[`get${this.utc}Month`]() + 1); }\n    get DD() { return pad0(this.date[`get${this.utc}Date`]()); }\n    get YYYY() { return pad0(this.date[`get${this.utc}FullYear`](), 4); }\n    get YY() { return this.YYYY.slice(2); }\n}\n","/** A classic `debounce` wrap function. */\nexport function debounce(runnable, ms = 50, scope) {\n    let timerId;\n    return function debounced() {\n        if (timerId !== undefined) {\n            clearTimeout(timerId);\n        }\n        const delayed = () => {\n            runnable.apply(scope || this, arguments);\n            timerId = undefined;\n        };\n        timerId = setTimeout(delayed, ms);\n    };\n}\n/** A classic `throttle` wrap function. */\nexport function throttle(runnable, time = 50, scope) {\n    let waiting = false;\n    let queued = false;\n    let context;\n    let args;\n    function delayed() {\n        if (queued) {\n            setTimeout(delayed, time);\n            runnable.apply(scope || context, args);\n        }\n        else {\n            waiting = false;\n        }\n        queued = false;\n    }\n    return function (...current_args) {\n        if (!waiting) {\n            waiting = true;\n            setTimeout(delayed, time);\n            runnable.apply(scope || this, current_args);\n        }\n        else {\n            context = this;\n            args = current_args;\n            queued = true;\n        }\n    };\n}\n/**\n * Allows to run a function as a `throttled` one, run it without a delay (`runNow`), or `clear` the deferred callback.\n *\n * @example\n * const {throttled, runNow, clear} = getThrottle(300, true);\n *\n * for (let i = 0; i < 100; i++) {\n *     throttled(() => {\n *         console.log(i);\n *     });\n *     await sleep(10);\n * }\n * runNow(); // run the last callback without delay\n */\nexport function getThrottle(ms = 1000, runFirstImmediately = true) {\n    let cb;\n    let timer;\n    function throttled(callback, runNow = false) {\n        cb = callback;\n        if (runFirstImmediately || runNow) {\n            runFirstImmediately = false;\n            execNow();\n            return;\n        }\n        if (timer) {\n            return;\n        }\n        timer = setTimeout(() => {\n            execNow(false);\n        }, ms);\n    }\n    function execNow(clearDelayed = true) {\n        if (clearDelayed) {\n            clearTimeout(timer);\n        }\n        timer = undefined;\n        return cb();\n    }\n    function clear() {\n        clearTimeout(timer);\n        timer = undefined;\n    }\n    return { throttled, runNow: execNow, clear };\n}\n","// @ts-ignore\nconst __setImmediate = typeof globalThis.setImmediate === \"function\" ? globalThis.setImmediate : null;\nconst setImmediate = __setImmediate || /*#__PURE__*/ (function () {\n    const { port1, port2 } = new MessageChannel();\n    const queue = [];\n    port1.onmessage = function () {\n        const callback = queue.shift();\n        callback();\n    };\n    return function setImmediateLike(callback) {\n        port2.postMessage(null);\n        queue.push(callback);\n    };\n})();\n/**\n * Sleeps `ms` milliseconds.\n * If param is `undefined` it sleeps until the next macro-task.\n * Note: With `0` real ms will be `4`+ ms.\n * @param {number?} ms\n * */\nexport function sleep(ms) {\n    if (ms === undefined) {\n        return new Promise(resolve => setImmediate(resolve));\n    }\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n/**\n * Interruptible `sleep`.\n * If was interrupted resolves with the interrupt reason (`signal.reason`).\n * @param {number} ms\n * @param {AbortSignal} signal\n */\nexport function sleepEx(ms, signal) {\n    if (signal.aborted) {\n        return Promise.resolve(signal.reason);\n    }\n    let timerId;\n    return new Promise(resolve => {\n        timerId = setTimeout(resolve, ms);\n        signal.onabort = () => {\n            clearTimeout(timerId);\n            resolve(signal.reason);\n        };\n    });\n}\n","export function isPlainObjectEmpty(obj) {\n    for (const _prop in obj) {\n        return false;\n    }\n    return true;\n}\n// Only for strings with hostname, not with an entire URL.\nexport function noWWW(hostname) {\n    return hostname.replace(/^www\\./, \"\");\n}\nconst hostnameRegEx = /^https?:\\/\\/(?<hostname>[^\\/:]+)/;\n// `userinfo` is not supported\nexport function getHostname(url) {\n    const matches = url.match(hostnameRegEx);\n    return matches?.[1] || \"\";\n}\nexport function getHostnameWithURL(url) {\n    return new URL(url).hostname;\n}\n/** Find dot positions in a string. */\nexport function findDots(str) {\n    const positions = [];\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === \".\") {\n            positions.push(i);\n        }\n    }\n    return positions;\n}\n/**\n * @example\n * getParentSubHosts(\"localhost\")    -> []\n * getParentSubHosts(\"example.com\")  -> []\n * getParentSubHosts(\"qwerty.example.com\")      -> [ \"example.com\" ]\n * getParentSubHosts(\"test.qwerty.example.com\") -> [ \"example.com\", \"qwerty.example.com\" ]\n */\nexport function getParentSubHosts(hostname) {\n    const positions = findDots(hostname);\n    const result = [];\n    if (positions.length > 1) {\n        for (let i = positions.length - 2; i >= 0; i--) {\n            const position = positions[i];\n            result.push(hostname.substring(position + 1));\n        }\n    }\n    return result;\n}\n/**\n * # Hostname rule matching\n *\n * Simple and performance oriented implementation with simplified WildCards support.\n * Only one (the first) hostname match's rules are applied.\n *\n * - \"example.com\"\n *  1. look for \"example.com\" rules, if none then do nothing (since, there are only 2 hostname parts).\n *\n *  - \"www.example.com\"\n *  1. look for \"example.com\" rules, if none then\n *  2. look for \"*.example.com\" rules.\n *\n *  - \"qwerty.example.com\"\n *  1. look for \"qwerty.example.com\", if none then\n *  2. look for \"*.example.com\".\n *\n *  - \"more.qwerty.example.com\"\n *  1. look for \"more.qwerty.example.com\", if none then\n *  2. look for \"*.example.com\", if none then\n *  3. look for \"*.qwerty.example.com\".\n */\n","import { getHostname, getParentSubHosts, isPlainObjectEmpty, noWWW } from \"./util-hostname\";\nconst TypeArray_TCCommands = [\n    \"trim-start\", \"trim-end\",\n    \"trim-start-end\",\n];\nconst TypeArray_TCCommands_SD = [\n    \"trim-regex\",\n];\nconst tcRuleStringPrefixes = [\"site:\", \"sites:\",\n    ...TypeArray_TCCommands.map(command => `${command}:`),\n    ...TypeArray_TCCommands_SD.map(command => `${command}:`),\n];\nexport function isTCRuleStringArray(array) {\n    return array.every(str => tcRuleStringPrefixes.some(prefix => str.startsWith(prefix)));\n}\nexport const knownCommands = new Set(TypeArray_TCCommands);\nexport const knownCommands_SD = new Set(TypeArray_TCCommands_SD);\nfunction isCommand(str) {\n    return knownCommands.has(str);\n}\nfunction isSingleDataCommand(str) {\n    return knownCommands_SD.has(str);\n}\nexport class TitleCleaner {\n    constructor({ ruleRecords, ruleRecordsWC }) {\n        this.ruleRecords = ruleRecords;\n        this.ruleRecordsWC = ruleRecordsWC;\n    }\n    static fromRuleStrings(rule_strings) {\n        const rules = TitleCleaner.compileRuleStrings(rule_strings);\n        return new TitleCleaner(rules);\n    }\n    static fromRuleRecords(rules) {\n        return new TitleCleaner(rules);\n    }\n    static compileRuleStrings(rule_strings) {\n        const ruleRecords = {};\n        const ruleRecordsWC = {};\n        let lastSites = [];\n        for (const rule_str of rule_strings) {\n            if (rule_str.startsWith(\"site:\")) {\n                lastSites = [noWWW(rule_str.slice(\"site:\".length).trim())];\n                continue;\n            }\n            else if (rule_str.startsWith(\"sites:\")) {\n                lastSites = rule_str.slice(\"sites:\".length).trim().split(/\\s+/);\n                lastSites = [...new Set(lastSites.map(noWWW))];\n                continue;\n            }\n            const rule = this.parseRuleString(rule_str);\n            if (!rule) {\n                // console.log(`[Wrong rule string] \"${rule_str}\"`); // For example, \"trim-start: \"\n                continue;\n            }\n            for (let lastSite of lastSites) {\n                let ruleStore = ruleRecords;\n                if (lastSite.startsWith(\"*.\")) {\n                    ruleStore = ruleRecordsWC;\n                    lastSite = lastSite.slice(2);\n                }\n                let siteRules = ruleStore[lastSite];\n                if (!siteRules) {\n                    siteRules = [];\n                    ruleStore[lastSite] = siteRules;\n                }\n                siteRules.push(rule);\n            }\n        }\n        if (isPlainObjectEmpty(ruleRecordsWC)) {\n            return { ruleRecords, ruleRecordsWC: null };\n        }\n        return { ruleRecords, ruleRecordsWC };\n    }\n    getRules(url) {\n        const hostname = getHostname(url);\n        const siteRules = this.ruleRecords[noWWW(hostname)];\n        if (siteRules) {\n            return siteRules;\n        }\n        if (this.ruleRecordsWC !== null) {\n            const hosts = getParentSubHosts(hostname);\n            for (const host of hosts) {\n                const siteRules = this.ruleRecordsWC[host];\n                if (siteRules) {\n                    return siteRules;\n                }\n            }\n        }\n        return null;\n    }\n    clean(url, title) {\n        const rules = this.getRules(url);\n        if (!rules) {\n            return title;\n        }\n        let newTitle = title.trim();\n        for (const rule of rules) {\n            newTitle = this.applyRule(newTitle, rule);\n        }\n        return newTitle;\n    }\n    applyRule(title, rule) {\n        if (rule.command === \"trim-start\") {\n            for (const prefix of rule.data) {\n                if (title.startsWith(prefix)) {\n                    const newTitle = title.replace(prefix, \"\").trimStart();\n                    return this.applyRule(newTitle, rule);\n                }\n            }\n        }\n        else if (rule.command === \"trim-end\") {\n            for (const postfix of rule.data) {\n                if (title.endsWith(postfix)) {\n                    const newTitle = title.slice(0, -postfix.length).trimEnd();\n                    return this.applyRule(newTitle, rule);\n                }\n            }\n        }\n        else if (rule.command === \"trim-start-end\") {\n            const [prefix, postfix] = rule.data;\n            if (title.startsWith(prefix) && title.endsWith(postfix)) {\n                const newTitle = title.slice(0, -postfix.length)\n                    .replace(prefix, \"\")\n                    .trim();\n                return this.applyRule(newTitle, rule);\n            }\n        }\n        else if (rule.command === \"trim-regex\") {\n            const regex = new RegExp(rule.data);\n            const newTitle = title.replace(regex, \"\").trim();\n            if (newTitle !== title) {\n                return this.applyRule(newTitle, rule);\n            }\n        }\n        return title;\n    }\n    static parseRuleString(rule_str) {\n        const commandEnd = rule_str.indexOf(\":\");\n        if (commandEnd === -1) {\n            return null;\n        }\n        const command = rule_str.slice(0, commandEnd);\n        if (isCommand(command)) {\n            let data;\n            const rulePart2 = rule_str.slice(commandEnd + 1);\n            if (rulePart2.charAt(0) === \":\") {\n                // one peace //\n                data = [rulePart2.slice(1).trim()];\n            }\n            else if (rulePart2.charAt(1) === \":\") {\n                // has a sep char //\n                const sep = rulePart2.charAt(0);\n                data = rulePart2.slice(2).trim().split(new RegExp(`\\\\s*\\\\${sep}+\\\\s*`));\n            }\n            else {\n                // just split by spaces //\n                data = rulePart2.trim().split(/\\s+/);\n            }\n            data = data.filter(d => d);\n            if (!data.length) {\n                return null;\n            }\n            return {\n                command,\n                data,\n            };\n        }\n        if (isSingleDataCommand(command)) {\n            const data = rule_str.slice(commandEnd + 1);\n            return {\n                command,\n                data,\n            };\n        }\n        return null;\n    }\n}\n","import { getHostname, getParentSubHosts, isPlainObjectEmpty, noWWW } from \"./util-hostname\";\nconst TypeArray_UCRuleCommands = [\n    \"https\", \"decode-url\",\n    \"recursive\", \"atob\",\n];\nconst TypeArray_UCRuleDataCommands = [\n    \"filter-start\", \"trim-start\",\n    \"prepend\", \"trim-regex\",\n    \"trim-search-param\", \"search-param\",\n];\nconst TypeArray_UCRuleMDataCommands = [\n    \"trim-search-params\",\n];\nconst commands = new Set(TypeArray_UCRuleCommands);\nconst dataCommands = new Set(TypeArray_UCRuleDataCommands);\nconst mDataCommands = new Set(TypeArray_UCRuleMDataCommands);\nfunction isCommand(str) {\n    return commands.has(str);\n}\nfunction isDataCommand(str) {\n    return dataCommands.has(str);\n}\nfunction isMultiDataCommand(str) {\n    return mDataCommands.has(str);\n}\nconst ucRuleStringPrefixes = new Set(TypeArray_UCRuleCommands.map(command => `${command}`));\nconst ucRuleDataStringPrefixes = [\n    \"site:\", \"sites:\",\n    ...TypeArray_UCRuleDataCommands.map(command => `${command}:`),\n    ...TypeArray_UCRuleMDataCommands.map(command => `${command}:`),\n];\nexport function isUCRuleStringArray(array) {\n    return array.every(str => ucRuleStringPrefixes.has(str)\n        || ucRuleDataStringPrefixes.some(prefix => str.startsWith(prefix)));\n}\nexport class UrlCleaner {\n    constructor({ ruleRecords, ruleRecordsWC }) {\n        this.ruleRecords = ruleRecords;\n        this.ruleRecordsWC = ruleRecordsWC;\n    }\n    static fromRuleStrings(rule_strings) {\n        const rules = UrlCleaner.compileRuleStrings(rule_strings);\n        return new UrlCleaner(rules);\n    }\n    static fromRuleRecords(rules) {\n        return new UrlCleaner(rules);\n    }\n    static compileRuleStrings(rule_strings) {\n        const ruleRecords = {};\n        const ruleRecordsWC = {};\n        let lastSites = [];\n        for (const rule_str of rule_strings) {\n            if (rule_str.startsWith(\"site:\")) {\n                lastSites = [noWWW(rule_str.slice(\"site:\".length).trim())];\n                continue;\n            }\n            else if (rule_str.startsWith(\"sites:\")) {\n                lastSites = rule_str.slice(\"sites:\".length).trim().split(/\\s+/);\n                lastSites = [...new Set(lastSites.map(noWWW))];\n                continue;\n            }\n            const rule = this.parseRuleString(rule_str);\n            if (!rule) {\n                console.log(`[Wrong rule string] \"${rule_str}\"`); // todo\n                continue;\n            }\n            for (let lastSite of lastSites) {\n                let ruleStore = ruleRecords;\n                if (lastSite.startsWith(\"*.\")) {\n                    ruleStore = ruleRecordsWC;\n                    lastSite = lastSite.slice(2);\n                }\n                let siteRules = ruleStore[lastSite];\n                if (!siteRules) {\n                    siteRules = [];\n                    ruleStore[lastSite] = siteRules;\n                }\n                siteRules.push(rule);\n            }\n        }\n        if (isPlainObjectEmpty(ruleRecordsWC)) {\n            return { ruleRecords, ruleRecordsWC: null };\n        }\n        return { ruleRecords, ruleRecordsWC };\n    }\n    getRules(url) {\n        const hostname = getHostname(url);\n        const siteRules = this.ruleRecords[noWWW(hostname)];\n        if (siteRules) {\n            return siteRules;\n        }\n        if (this.ruleRecordsWC !== null) {\n            const hosts = getParentSubHosts(hostname);\n            for (const host of hosts) {\n                const siteRules = this.ruleRecordsWC[host];\n                if (siteRules) {\n                    return siteRules;\n                }\n            }\n        }\n        return null;\n    }\n    clean(url) {\n        const rules = this.getRules(url);\n        if (!rules) {\n            return url;\n        }\n        return new RuleApplier(this, url, rules).applyRules();\n    }\n    static parseRuleString(rule_str) {\n        if (isCommand(rule_str)) {\n            return {\n                command: rule_str,\n            };\n        }\n        else {\n            const i = rule_str.indexOf(\":\");\n            if (i !== -1) {\n                const [command, data] = [rule_str.slice(0, i), rule_str.slice(i + 1)];\n                if (isDataCommand(command)) {\n                    return {\n                        command,\n                        data,\n                    };\n                }\n                else if (isMultiDataCommand(command)) {\n                    const array = data.split(/\\s+/);\n                    if (array.length > 1) {\n                        return {\n                            command,\n                            data: array,\n                        };\n                    }\n                    return {\n                        command,\n                        data,\n                    };\n                }\n            }\n        }\n        return null;\n    }\n}\nclass RuleApplier {\n    constructor(cleaner, url, rules) {\n        this.index = -1;\n        this.cleaner = cleaner;\n        this.initUrl = url;\n        this.url = url;\n        this.rules = rules;\n    }\n    applyRules() {\n        this.nextRule();\n        return this.url;\n    }\n    nextRule() {\n        this.index++;\n        const next = this.rules[this.index];\n        if (next) {\n            // @ts-ignore\n            // TS2345: Argument of type UCAnyRule is not assignable to parameter of type never\n            // The intersection UCDataRule & UCRule was reduced to never because property command has conflicting types in some constituents.\n            // Type UCDataRule is not assignable to type never\n            this[next.command](next);\n        }\n    }\n    // --- Filters --- //\n    [\"filter-start\"](rule) {\n        if (this.url.startsWith(rule.data)) {\n            this.nextRule();\n        }\n    }\n    [\"trim-start\"](rule) {\n        if (this.url.startsWith(rule.data)) {\n            this.url = this.url.replace(rule.data, \"\");\n            this.nextRule();\n        }\n    }\n    [\"trim-regex\"](rule) {\n        const regex = new RegExp(rule.data);\n        const match = regex.exec(this.url);\n        if (match?.groups) {\n            Object.entries(match.groups).forEach(([k, v]) => {\n                if (k.startsWith(\"trim\")) {\n                    this.url = this.url.replace(v, \"\");\n                }\n            });\n        }\n        this.nextRule();\n    }\n    [\"trim-search-params\"](rule) {\n        const u = new URL(this.url);\n        if (Array.isArray(rule.data)) {\n            for (const param of rule.data) {\n                u.searchParams.delete(param);\n            }\n        }\n        else {\n            u.searchParams.delete(rule.data);\n        }\n        this.url = u.toString();\n        this.nextRule();\n    }\n    [\"trim-search-param\"](rule) {\n        const u = new URL(this.url);\n        u.searchParams.delete(rule.data);\n        this.url = u.toString();\n        this.nextRule();\n    }\n    [\"search-param\"](rule) {\n        const u = new URL(this.url);\n        const spUrl = u.searchParams.get(rule.data);\n        if (spUrl !== null) {\n            this.url = spUrl;\n            this.nextRule();\n        }\n    }\n    [\"prepend\"](rule) {\n        this.url = rule.data + this.url;\n        this.nextRule();\n    }\n    [\"https\"]() {\n        if (this.url.startsWith(\"http://\")) {\n            this.url = this.url.replace(\"http://\", \"https://\");\n        }\n        this.nextRule();\n    }\n    [\"decode-url\"]() {\n        this.url = decodeURIComponent(this.url)\n            .replaceAll(/\\s+/g, \"\");\n        this.nextRule();\n    }\n    [\"atob\"]() {\n        try {\n            this.url = atob(this.url);\n            this.nextRule();\n        }\n        catch (e) {\n            console.log(this.url);\n            console.error(e);\n        }\n    }\n    [\"recursive\"]() {\n        if (this.url !== this.initUrl) {\n            this.url = this.cleaner.clean(this.url); // for a case when the url will have a new hostname\n        }\n    }\n}\n"],"names":["isString","value","hashString","str","hash","i","formatDate","dateValue","pattern","utc","firefoxDateFix","date","formatter","DateFormatter","args","property","pad0","count","debounce","runnable","ms","scope","timerId","throttle","time","waiting","queued","context","delayed","current_args","__setImmediate","setImmediate","port1","port2","queue","callback","sleep","resolve","sleepEx","signal","isPlainObjectEmpty","obj","_prop","noWWW","hostname","hostnameRegEx","getHostname","url","findDots","positions","getParentSubHosts","result","position","TypeArray_TCCommands","TypeArray_TCCommands_SD","TypeArray_UCRuleCommands","TypeArray_UCRuleDataCommands","TypeArray_UCRuleMDataCommands","commands","dataCommands","mDataCommands","isCommand","isDataCommand","isMultiDataCommand","ucRuleStringPrefixes","command","ucRuleDataStringPrefixes","isUCRuleStringArray","array","prefix","UrlCleaner","ruleRecords","ruleRecordsWC","rule_strings","rules","lastSites","rule_str","rule","lastSite","ruleStore","siteRules","hosts","host","RuleApplier","data","cleaner","next","match","k","v","u","param","spUrl","e"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}